# 17.跳表：为什么Redis一定要用跳表来实现有序集合？

markdown文件已上传至[github](https://github.com/clearlove-AI/The-beauty-of-data-structures-and-algorithms)

因为二分查找底层依赖的是数组随机访问的特性，所以只能用数组来实现。如果数据存储在链表中，我们只需要对链表稍加改造，就可以支持类似“二分”的查找算法。我们把改造之后的数据结构叫做跳表（Skip list）。

**跳表**：是一种各方面性能都比较优秀的动态数据结构，可以支持快速地插入、删除、查找操作，写起来也不复杂，甚至可以替代红黑树（Red-black tree）。

## 1.如何理解“跳表”？

单链表中即使存储的数据有序，我们要查找一个元素也要从头到尾遍历链表，这样查找效率很低，时间复杂度为O(n)。

为了提高查找效率，可以对链表建立一级索引，每两个结点提取一个节点到上一级，把抽出来的那一级叫做**索引**或**索引层**。如图，down表示为down指针。

<img src="https://static001.geekbang.org/resource/image/14/8e/14753c824a5ee4a976ea799727adc78e.jpg" alt="img" style="zoom:50%;" />

如果我们现在要查找某个结点，比如 16。我们可以先在索引层遍历，当遍历到索引层中值为 13 的结点时，我们发现下一个结点是 17，那要查找的结点 16 肯定就在这两个结点之间。然后我们通过索引层结点的 down 指针，下降到原始链表这一层，继续遍历。这个时候，我们只需要再遍历 2 个结点，就可以找到值等于 16 的这个结点了。这样，原来如果要查找 16，需要遍历 10 个结点，现在只需要遍历 7 个结点。

**加一层索引后，查找一个结点需要遍历的结点个数减少了，也就是查找效率提高了。**

在第一级索引的基础上，每两个结点抽出一个结点到第二级索引，如下图，现在查找16只需要遍历6个节点了，遍历的结点又减少了。

<img src="https://static001.geekbang.org/resource/image/49/65/492206afe5e2fef9f683c7cff83afa65.jpg" alt="img" style="zoom:50%;" />

假如有64个结点的链表，建立五级索引，如下图：

<img src="https://static001.geekbang.org/resource/image/46/a9/46d283cd82c987153b3fe0c76dfba8a9.jpg" alt="img" style="zoom:50%;" />

在没有索引的时候，查找62需要遍历62个结点，现在只需要遍历11个结点，当n比较大的时候，查找效率的提升会非常明显。

## 2.用跳表查询到底有多快？

在一个单链表中查询某个数据的时间复杂度是$O(n)$。 在一个具有多级索引的跳表中，查询某个数据的时间复杂度是多少呢？

把问题分解一下，先来看这样一个问题，如果链表里有 n 个结点，会有多少级索引呢？

每两个结点会抽出一个结点作为上一级索引的结点，那第一级索引的结点个数大约就是 n/2，第二级索引的结点个数大约就是 n/4，第三级索引的结点个数大约就是 n/8，依次类推，也就是说，**第 k 级索引的结点个数是第 k-1 级索引的结点个数的 1/2，那第 k级索引结点的个数就是 $n/(2^k)$。**

假设索引有 h 级，最高级的索引有 2 个结点。通过上面的公式，我们可以得到 $n/(2^h)=2$，从而求得 h=log2n-1。如果包含原始链表这一层，整个跳表的高度就是$ log_2n$。我们在跳表中查询某个数据的时候，如果每一层都要遍历 m 个结点，那在跳表中查询一个数据的**时间复杂度就是 O(m*logn)**。

那这个 m 的值是多少呢？按照前面这种索引结构，我们每一级索引都最多只需要遍历 3 个结点，也就是说 m=3，为什么是 3 呢？

假设我们要查找的数据是 x，在第 k 级索引中，我们遍历到 y 结点之后，发现 x 大于 y，小于后面的结点 z，所以我们通过 y 的 down 指针，从第 k 级索引下降到第 k-1 级索引。在第 k-1 级索引中，y 和 z 之间只有 3 个结点（包含 y 和 z），所以，我们在 K-1 级索引中最多只需要遍历 3 个结点，依次类推，每一级索引都最多只需要遍历 3 个结点。

<img src="https://static001.geekbang.org/resource/image/d0/0c/d03bef9a64a0368e6a0d23ace8bd450c.jpg" alt="img" style="zoom:50%;" />

通过上面的分析，我们得到 m=3，所以**在跳表中查询任意数据的时间复杂度就是 O(logn)**。这个查找的时间复杂度跟二分查找是一样的。换句话说，我们其实是基于单链表实现了二分查找。

## 3.跳表是不是很浪费内存

跳表的空间复杂度分析并不难，我在前面说了，假设原始链表大小为 n，那第一级索引大约有 n/2 个结点，第二级索引大约有 n/4 个结点，以此类推，每上升一级就减少一半，直到剩下 2 个结点。如果我们把每层索引的结点数写出来，就是一个等比数列。

<img src="https://static001.geekbang.org/resource/image/10/55/100e9d6e5abeaae542cf7841be3f8255.jpg" alt="img" style="zoom:50%;" />

这几级索引的结点总和就是 n/2+n/4+n/8…+8+4+2=n-2。所以，跳表的**空间复杂度是 O(n)**。也就是说，如果将包含 n 个结点的单链表构造成跳表，我们需要额外再用接近 n 个结点的存储空间。如果我们每三个结点或五个结点抽一个结点到上层索引，需要的索引结点的存储空间将更少。

实际软件开发过程中，原始链表中存储的有可能是很大的对象，而索引结点只需要存储关键值，并不需要存储对象，所以当对象比索引结点大很多时，那索引所占的额外空间就可以忽略了。

## 4.高效的动态插入和删除

**跳表这个动态数据结构，不仅支持查找操作，还支持动态的插入、删除操作，而且插入、删除操作的时间复杂度也是 O(logn)。**

### 4.1在跳表中插入一个元素

单链表一旦定位好要插入数据的位置，插入结点的时间复杂度是O(1)。查找插入位置是比较费时的。

对于跳表来说，查找时间复杂度为$O(logn)$,所以插入时间复杂度为$O(logn)$。

### 4.2 跳表中的删除操作

如果这个结点在索引中也有出现，我们除了要删除原始链表中的结点，还要删除索引中的。因为单链表中的删除操作需要拿到要删除结点的前驱结点，然后通过指针操作完成删除。所以在查找要删除的结点的时候，一定要获取前驱结点。当然，如果我们用的是双向链表，就不需要考虑这个问题了。

## 5.跳表索引动态更新

当我们不停地往跳表中插入数据时，如果我们不更新索引，就有可能出现某 2 个索引结点之间数据非常多的情况。极端情况下，跳表还会退化成单链表。

<img src="https://static001.geekbang.org/resource/image/c8/c5/c863074c01c26538cf0134eaf8dc67c5.jpg" alt="img" style="zoom:50%;" />

如果你了解红黑树、AVL 树这样平衡二叉树，你就知道它们是通过左右旋的方式保持左右子树的大小平衡（如果不了解也没关系，我们后面会讲），而跳表是通过随机函数来维护前面提到的“平衡性”。当我们往跳表中插入数据的时候，我们可以选择同时将这个数据插入到部分索引层中。我们通过一个随机函数，来决定将这个结点插入到哪几级索引中，比如随机函数生成了值 K，那我们就将这个结点添加到第一级到第 K 级这 K 级索引中。随机函数的选择很有讲究，从概率上来讲，能够保证跳表的索引大小和数据大小平衡性，不至于性能过度退化。

## 6.解答开篇

**为什么 Redis 要用跳表来实现有序集合，而不是红黑树？**

Redis 中的有序集合支持的核心操作主要有下面这几个：

插入一个数据；

删除一个数据；

查找一个数据；

按照区间查找数据（比如查找值在[100, 356]之间的数据）；

迭代输出有序序列。

其中，插入、删除、查找以及迭代输出有序序列这几个操作，红黑树也可以完成，时间复杂度跟跳表是一样的。但是，按照区间来查找数据这个操作，红黑树的效率没有跳表高。对于按照区间查找数据这个操作，跳表可以做到 O(logn) 的时间复杂度定位区间的起点，然后在原始链表中顺序往后遍历就可以了。这样做非常高效。当然，Redis 之所以用跳表来实现有序集合，还有其他原因，比如，跳表更容易代码实现。虽然跳表的实现也不简单，但比起红黑树来说还是好懂、好写多了，而简单就意味着可读性好，不容易出错。还有，跳表更加灵活，它可以通过改变索引构建策略，有效平衡执行效率和内存消耗。不过，跳表也不能完全替代红黑树。因为红黑树比跳表的出现要早一些，很多编程语言中的 Map 类型都是通过红黑树来实现的。我们做业务开发的时候，直接拿来用就可以了，不用费劲自己去实现一个红黑树，但是跳表并没有一个现成的实现，所以在开发中，如果你想使用跳表，必须要自己实现。

## 7.思考题

如果每三个或者五个结点提取一个结点作为上级索引，对应的在跳表中查询数据的时间复杂度是多少呢？

如果每三个或者五个节点提取一个节点作为上级索引，那么对应的查询数据时间复杂度，应该也还是 O(logn)。

假设每 5 个节点提取，那么最高一层有 5 个节点，而跳表高度为 log5n，每层最多需要查找 5 个节点，即 O(mlogn) 中的 m = 5，最终，时间复杂度为 O(logn)。

空间复杂度也还是 O(logn)，虽然省去了一部分索引节点，但是似乎意义不大。

## 8.参考



这个是我学习王争老师的《数据结构与算法之美》所做的笔记，王争老师是前谷歌工程师，该课程截止到目前已有87244人付费学习，质量不用多说。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200725000844480.png)

截取了课程部分目录，课程结合实际应用场景，从概念开始层层剖析，由浅入深进行讲解。本人之前也学过许多数据结构与算法的课程，唯独王争老师的课给我一种茅塞顿开的感觉，强烈推荐大家购买学习。课程二维码我已放置在下方，大家想买的话可以扫码购买。

<img src="https://img-blog.csdnimg.cn/20200725000905707.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N1cHJlbWVfMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" />

本人做的笔记并不全面，推荐大家扫码购买课程进行学习，而且课程非常便宜，学完后必有很大提高。

<img src="https://img-blog.csdnimg.cn/20200725001012449.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N1cHJlbWVfMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:30%;" />